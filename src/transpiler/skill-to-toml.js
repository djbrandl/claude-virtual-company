/**
 * SKILL.md to TOML Transpiler
 * Generates Gemini CLI TOML command files from Claude Code skills
 */

class SkillToToml {
  constructor(options = {}) {
    this.options = options;
  }

  /**
   * Transpile a parsed skill to TOML command format
   * @param {Object} skill - Parsed skill { frontmatter, body }
   * @param {string} skillName - Skill name
   * @returns {string} TOML content
   */
  transpile(skill, skillName) {
    const { frontmatter, body } = skill;

    const sections = [];

    // File header comment
    sections.push(this.generateHeader(skillName));

    // Command metadata
    sections.push(this.generateCommandSection(frontmatter, skillName));

    // Arguments
    sections.push(this.generateArgsSection(frontmatter, body));

    // Execution steps
    sections.push(this.generateStepsSection(frontmatter, skillName, body));

    return sections.join('\n\n');
  }

  /**
   * Generate file header comment
   * @param {string} skillName - Skill name
   * @returns {string} Header comment
   */
  generateHeader(skillName) {
    return `# ${skillName} command for Gemini CLI
# Generated by Claude Virtual Company Transpiler
#
# Usage: /${skillName} "your task here"
#
# This command invokes the ${this.formatTitle(skillName)} role
# from the Claude Virtual Company framework.`;
  }

  /**
   * Format skill name as title
   * @param {string} name - Skill name
   * @returns {string} Formatted title
   */
  formatTitle(name) {
    return name
      .replace(/^company-?/, '')
      .split('-')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ') || 'Company Command';
  }

  /**
   * Generate [command] section
   * @param {Object} frontmatter - Skill frontmatter
   * @param {string} skillName - Skill name
   * @returns {string} Command section TOML
   */
  generateCommandSection(frontmatter, skillName) {
    const description = this.escapeTomlString(
      frontmatter.description || `Execute the ${this.formatTitle(skillName)} role`
    );

    const lines = [
      '[command]',
      `description = "${description}"`
    ];

    // Add model preference as a hint
    if (frontmatter.agent) {
      const agentHints = {
        'Explore': 'exploration and research',
        'Plan': 'planning and design',
        'general-purpose': 'implementation'
      };
      const hint = agentHints[frontmatter.agent] || frontmatter.agent;
      lines.push(`# Recommended approach: ${hint}`);
    }

    return lines.join('\n');
  }

  /**
   * Generate [command.args] section
   * @param {Object} frontmatter - Skill frontmatter
   * @param {string} body - Skill body
   * @returns {string} Args section TOML
   */
  generateArgsSection(frontmatter, body) {
    const lines = ['[command.args]'];

    // Main task argument
    const argHint = frontmatter['argument-hint'] || 'task description';
    const hasArgs = body.includes('$ARGUMENTS') || body.includes('{{args}}');

    if (hasArgs) {
      lines.push(`task = { description = "The task or goal to accomplish", required = true, hint = "${argHint}" }`);
    }

    // Check for common optional patterns in body
    if (body.includes('--force') || body.includes('force flag')) {
      lines.push(`force = { description = "Force overwrite existing files", required = false, default = false }`);
    }

    if (body.includes('--verbose') || body.includes('verbose')) {
      lines.push(`verbose = { description = "Show detailed output", required = false, default = false }`);
    }

    return lines.join('\n');
  }

  /**
   * Generate [command.steps] section
   * @param {Object} frontmatter - Skill frontmatter
   * @param {string} skillName - Skill name
   * @param {string} body - Skill body
   * @returns {string} Steps section TOML
   */
  generateStepsSection(frontmatter, skillName, body) {
    const lines = ['[command.steps]'];

    // Step 1: Load context
    lines.push(this.generateContextLoadStep(skillName, body));

    // Step 2: Execute role
    lines.push(this.generateExecutionStep(frontmatter, skillName));

    // Step 3: Save outputs
    lines.push(this.generateOutputStep(frontmatter, skillName, body));

    return lines.join('\n\n');
  }

  /**
   * Generate context loading step
   * @param {string} skillName - Skill name
   * @param {string} body - Skill body
   * @returns {string} Step TOML
   */
  generateContextLoadStep(skillName, body) {
    const files = this.extractRequiredFiles(body);
    const fileList = files.map(f => `- ${f}`).join('\\n');

    return `1 = """
STEP 1: Load Context

Read the role context file:
.gemini/context/${skillName}.md

Then read these state files (if they exist):
${fileList}

Parse the JSON files and keep track of:
- Current phase from state.json
- Configuration from config.json
- Any pending messages in the inbox
"""`;
  }

  /**
   * Generate execution step
   * @param {Object} frontmatter - Skill frontmatter
   * @param {string} skillName - Skill name
   * @returns {string} Step TOML
   */
  generateExecutionStep(frontmatter, skillName) {
    const roleName = this.formatTitle(skillName);
    const tools = frontmatter['allowed-tools'] || ['Read', 'Write', 'Bash'];

    return `2 = """
STEP 2: Execute ${roleName}

Follow the instructions in the context file to complete the task:
{{args.task}}

Recommended tools for this role:
${tools.map(t => `- ${t}`).join('\\n')}

${this.getAgentGuidance(frontmatter.agent)}

Work through the role's defined process step by step.
"""`;
  }

  /**
   * Get guidance based on agent type
   * @param {string} agent - Agent type
   * @returns {string} Guidance text
   */
  getAgentGuidance(agent) {
    switch (agent) {
      case 'Explore':
        return `Approach: Exploration Mode
- Focus on reading and understanding before acting
- Gather all relevant context first
- Document findings thoroughly`;
      case 'Plan':
        return `Approach: Planning Mode
- Create detailed plans before implementation
- Consider alternatives and trade-offs
- Document decisions with rationale`;
      case 'general-purpose':
      default:
        return `Approach: Implementation Mode
- Follow the established design
- Write clean, tested code
- Document as you go`;
    }
  }

  /**
   * Generate output step
   * @param {Object} frontmatter - Skill frontmatter
   * @param {string} skillName - Skill name
   * @param {string} body - Skill body
   * @returns {string} Step TOML
   */
  generateOutputStep(frontmatter, skillName, body) {
    const outputDir = this.extractOutputDirectory(body, skillName);

    return `3 = """
STEP 3: Save Outputs

After completing the role:

1. Write all artifacts to:
   ${outputDir}

2. Update the state file:
   Write new phase to .company/state.json

3. Create handoff document if needed:
   Write to ${outputDir}/handoff-*.md

4. Notify orchestrator:
   Write completion message to .company/inboxes/orchestrator/

Verify all outputs are saved before completing.
"""`;
  }

  /**
   * Extract required files from body
   * @param {string} body - Skill body
   * @returns {Array} File paths
   */
  extractRequiredFiles(body) {
    const files = new Set([
      '.company/state.json',
      '.company/config.json'
    ]);

    // Find explicit file references
    const patterns = [
      /\.company\/[a-z0-9\-\/]+\.(json|md)/gi,
      /\.planning\/[A-Z\-]+\.(md|json)/gi
    ];

    for (const pattern of patterns) {
      const matches = body.matchAll(pattern);
      for (const match of matches) {
        files.add(match[0]);
      }
    }

    return [...files];
  }

  /**
   * Extract output directory from body
   * @param {string} body - Skill body
   * @param {string} skillName - Skill name
   * @returns {string} Output directory path
   */
  extractOutputDirectory(body, skillName) {
    // Look for artifact directory references
    const match = body.match(/\.company\/artifacts\/([a-z\-]+)\//i);
    if (match) {
      return `.company/artifacts/${match[1]}/`;
    }

    // Default based on skill name
    const role = skillName.replace('company-', '');
    return `.company/artifacts/${role}/`;
  }

  /**
   * Escape string for TOML
   * @param {string} str - Input string
   * @returns {string} Escaped string
   */
  escapeTomlString(str) {
    return str
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/\t/g, '\\t');
  }
}

module.exports = SkillToToml;
